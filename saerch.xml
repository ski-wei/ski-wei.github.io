<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>verilog 学习笔记(一)</title>
      <link href="/2023/06/21/verilog-xue-xi-bi-ji-yi/"/>
      <url>/2023/06/21/verilog-xue-xi-bi-ji-yi/</url>
      
        <content type="html"><![CDATA[<h2 id="Verilog-高级知识点"><a href="#Verilog-高级知识点" class="headerlink" title="Verilog 高级知识点"></a>Verilog 高级知识点</h2><p>包括<strong>阻塞与非阻塞赋值</strong>、<code>assign</code><strong>和</strong><code>always</code>语句差异、<strong>锁存器</strong>、<strong>状态机</strong>、<strong>模块化设计</strong> 等。</p><h3 id="阻塞赋值-Blocking"><a href="#阻塞赋值-Blocking" class="headerlink" title="阻塞赋值 (Blocking)"></a>阻塞赋值 (Blocking)</h3><p>在一个<code>always</code>块中，后面的语句会受到前语句的影响，即一条阻塞赋值语句没有执行结束的情况下，那么该语句后面的语句就不能被执行。 <strong>阻塞赋值</strong>的符号为<code>=</code>。</p><pre class="line-numbers language-" data-language=""><div class="caption"><span>verilog</span></div><code class="language-">always @(posedge clk or negedge rst_n) begin    if (!rst_n)begin        a = 1;        b = 2;        c = 3;    end    else begin        a = 0;        b = a;        c = b;    endend<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="blocking.png" alt=""></p><h3 id="非阻塞赋值-Non-Blocking"><a href="#非阻塞赋值-Non-Blocking" class="headerlink" title="非阻塞赋值(Non-Blocking)"></a>非阻塞赋值(Non-Blocking)</h3><p><code>&lt;=</code>代表非阻塞赋值，非阻塞赋值的时机是由时钟节拍决定的，在时钟上升沿到来时，执行赋值语句右边，然后将<code>begin-end</code>之间的所有赋值语句同时赋值到赋值语句的左边，即，所有的赋值语句是并行执行的。</p><p>如果将上述例子中的<code>=</code>全部替换为<code>&lt;=</code>，则执行结果的时序图变为：<br><img src="non-block.png" alt=""></p><blockquote><ul><li>描述<strong>组合逻辑</strong>时， 一般使用阻塞赋值;</li><li>描述<strong>时序逻辑</strong>时，一般使用非阻塞赋值。</li></ul></blockquote><h3 id="assign-和-always"><a href="#assign-和-always" class="headerlink" title="assign 和 always"></a><code>assign</code> 和 <code>always</code></h3><p><code>assign</code> 和 <code>always</code> 是<code>Verilog</code>中常用的两个基本语句。</p><ul><li><code>assign</code> 语句不能与时钟关联</li><li><code>always</code> 可以与时钟关联，也可以不关联</li></ul><p>与时钟关联的语句与<strong>寄存器</strong>内容/变量交互, 而不与时钟关联的语句则一般与<code>wire</code>变量交互。</p><h3 id="latch"><a href="#latch" class="headerlink" title="latch"></a><code>latch</code></h3><p><code>latch</code>是指锁存器，是一种对脉冲电平敏感的存储单元电路。<br>||latch|register|<br>|—-|—-|—-|<br>|触发方式|电平|边沿|<br>|产生方式|组合逻辑|时序逻辑|</p><p><code>latch</code> 的主要危害是会产生毛刺，这种毛刺会影响下一级电路的功能。一般应尽量避免<code>latch</code>的使用。一般的产生原因是再组合逻辑中，<code>if</code>或<code>else</code>语句描述不完整，比如<code>if</code>缺少<code>else</code>分支，<code>case</code>缺少<code>default</code>分支，导致代码在综合过程中出现了<code>latch</code>。</p><h3 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h3><p>状态机相当于一个控制器，它将一项功能的完成分解为若干步，每一步对应于二进制的一个状态，通过预先设计的顺序在各状态之间切换，状态转换的过程就是实现逻辑功能的过程。</p><h4 id="三段式状态机"><a href="#三段式状态机" class="headerlink" title="三段式状态机"></a>三段式状态机</h4><p>三段式状态机的基本格式是：</p><ul><li>第一个<code>always</code>语句实现同步状态跳转;</li><li>第二个<code>always</code>语句采用组合逻辑判断状态转移条件;</li><li>第三个<code>always</code>语句描述状态输出(可以是组合电路或时序电路).</li></ul><h3 id="模块化设计"><a href="#模块化设计" class="headerlink" title="模块化设计"></a>模块化设计</h3><p>模块化设计是<code>FPGA</code>设计中一个很重要的技巧，它能够使一个大型设计的分工协作、仿真测试更加容易，代码维护或升级更加便利，当更改某个子模块时，不会影响其它模块的实现结果。进行模块化、标准化设计的最终目的就是提高设计的通用性，减少不同项目中同一功能设计和验证引入的工作量。划分模块的基本原则是子模块功能相对独立、模块内部联系尽量紧密、模块间的连接尽量简单。</p><p><code>Verilog</code>通过模块调用或模块实例化的方式来实现这些子模块与高层模块的连接，有利于简化每一个模块的代码，易于维护和修改。</p><p>子模块的例化包括端口信号的例化和参数信号的例化。</p><p><img src="parameter_serial.png" alt=""></p><p>在对参数进行例化时, 在模块名的后面加上”#”, 表示后面跟着的是参数列表。<br>注: <code>parameter</code>参数可以在上层模块例化，而<code>localparameter</code>指定的参数只能在模块本地例化，不可以在上层模块例化。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Verilog </tag>
            
            <tag> FPGA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMake 学习</title>
      <link href="/2023/06/07/cmake-xue-xi/"/>
      <url>/2023/06/07/cmake-xue-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><blockquote><p><code>CMake</code> 文件中的所有内容不是指令调用就是注释。</p></blockquote><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><ul><li>单行注释 <code>#</code></li><li>多行注释 </li></ul><p>例如： 以一个方括号和任意数量的等号以及另一个方括号开始，到匹配的反转括号处结束。<br></p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token comment">#[=[</span>bracket comment    <span class="token comment">#[[</span>        nested bracket comment    <span class="token comment">#]]</span><span class="token comment">#]=]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p><strong>注：可以在<code>括号注释</code>的第一行添加另一个<code>#</code>来禁用多行注释。</strong></p><h3 id="执行指令"><a href="#执行指令" class="headerlink" title="执行指令"></a>执行指令</h3><p>执行指令是<code>CMake</code>列表文件的基本功能，必须提供它的名称，后面跟着圆括号，在圆括号中<br>可以包含一个以空格分隔的指令参数列表。<br>例如：<br></p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">message</span><span class="token punctuation">(</span><span class="token string">"hello world"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p></p><p>这些指令包括三类：</p><ul><li>脚本指令： 会改变指令处理器、访问变量的状态，并影响其他指令和环境</li><li>项目指令：这些指令在项目中可用，操纵项目状态并构建目标</li><li><code>CTest</code>指令：这些指令在<code>CTest</code>脚本中可用，管理测试</li></ul><h3 id="指令参数"><a href="#指令参数" class="headerlink" title="指令参数"></a>指令参数</h3><p><code>CMake</code>提供了三种类型的参数：</p><ul><li>方括号参数</li><li>引号参数</li><li>非引号参数</li></ul><h4 id="方括号参数"><a href="#方括号参数" class="headerlink" title="方括号参数"></a>方括号参数</h4><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">message</span><span class="token punctuation">(</span>[[multilinebracketargument]]<span class="token punctuation">)</span><span class="token keyword">message</span><span class="token punctuation">(</span>[==[because we used two equal-signs <span class="token string">"=="</span>following is still a single argument:{ <span class="token string">"petsArray"</span> = [[<span class="token string">"mouse"</span>,<span class="token string">"cat"</span>],[<span class="token string">"dog"</span>]] <span class="token punctuation">}</span>]==]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出为：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ cmake <span class="token parameter variable">-P</span> chapter02/01-arguments/bracket.cmakemultilinebracketargumentbecause we used two equal-signs <span class="token string">"=="</span>following is still a single argument:<span class="token punctuation">{</span> <span class="token string">"petsArray"</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">"mouse"</span>,<span class="token string">"cat"</span><span class="token punctuation">]</span>,<span class="token punctuation">[</span><span class="token string">"dog"</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="引号参数"><a href="#引号参数" class="headerlink" title="引号参数"></a>引号参数</h4><p>引号参数包括空格，包括转义序列(与<code>C++</code>字符串相似)，也可以引用变量像 <code>${name}</code>。</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">message</span><span class="token punctuation">(</span><span class="token string">"1. escape sequence: \" \n in a quoted argument"</span><span class="token punctuation">)</span><span class="token keyword">message</span><span class="token punctuation">(</span><span class="token string">"2. multi...line"</span><span class="token punctuation">)</span><span class="token keyword">message</span><span class="token punctuation">(</span><span class="token string">"3. and a variable reference: <span class="token interpolation"><span class="token punctuation">${</span><span class="token variable">CMAKE_VERSION</span><span class="token punctuation">}</span></span>"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>输出为：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ cmake <span class="token parameter variable">-P</span> chapter02/01-arguments/quoted.cmake<span class="token number">1</span>. escape sequence: "<span class="token keyword">in</span> a quoted argument<span class="token number">2</span>. multi<span class="token punctuation">..</span>.line<span class="token number">3</span>. and a variable reference: <span class="token number">3.16</span>.3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="非引号参数"><a href="#非引号参数" class="headerlink" title="非引号参数"></a>非引号参数</h4><p>不加引号的实参中的字符串默认不分隔。不加引号的实参计算转义序列和变量引用，但要小心<br>使用分号 (;)，就像在 <code>CMake</code> 中一样，其会当作分隔符对待。 <code>CMake</code> 会将包含它的参<br>数拆分为多个参数，可以使用反斜杠对其进行转义 (\;)。这就是 <code>CMake</code> 管理列表的方式。</p><p><img src="2-2.png" alt=""></p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">message</span><span class="token punctuation">(</span>a\ single\ argument<span class="token punctuation">)</span><span class="token keyword">message</span><span class="token punctuation">(</span>two arguments<span class="token punctuation">)</span><span class="token keyword">message</span><span class="token punctuation">(</span>three;separated;arguments<span class="token punctuation">)</span><span class="token keyword">message</span><span class="token punctuation">(</span><span class="token punctuation">${</span><span class="token variable">CMAKE_VERSION</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment"># a variable reference</span><span class="token keyword">message</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment"># matching parentheses</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出为：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ cmake <span class="token parameter variable">-P</span> chapter02/01-arguments/unquoted.cmakea single argumenttwoargumentsthreeseparatedarguments<span class="token number">3.16</span>.3<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p><code>CMake</code> 中有三类变量：普通变量、缓存变量和环境变量，且它们还处在不同的作用域中。<br>基本的变量操作指令是<code>set()</code>和<code>unset()</code></p><h4 id="引用变量"><a href="#引用变量" class="headerlink" title="引用变量"></a>引用变量</h4><p>求值时，<code>CMake</code> 将遍历作用域堆栈，并将 <code>${var}</code> 替换为值，若没有找到变量则替换为空字符<br>串。<br>涉及变量类别时，变量引用的工作方式：</p><ul><li><code>${}</code> 用于引用普通变量或缓存变量</li><li><code>$ENV{}</code> 用于引用环境变量</li><li><code>$CACHE{}</code> 用于引用缓存变量</li></ul><h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><p><code>CMake</code> 生成环境中用于启动 <code>CMake</code> 进程的变量的副本，并使它们在单一的全局作用域中可用。</p><p><code>CMake</code> 还允许设置变量 <code>set()</code> 和取消设置变量 <code>unset()</code>，但更改只会在运行的 <code>CMake</code> 进<br>程中对本地副本进行，而不会对实际的系统环境进行更改; 此外，这些更改对于构建或测试的后续运行<br>不可见。<br>要修改或创建一个变量，使用 <code>set(ENV{&lt;variable&gt;} &lt;value&gt;)</code> 指令:</p><pre class="line-numbers language-none"><code class="language-none">set(ENV(CXX) "clang++")<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>要清除环境变量，使用 <code>unset(ENV{&lt;variable&gt;})</code> :</p><pre class="line-numbers language-none"><code class="language-none">unset(ENV(VERBOSE))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="缓存变量"><a href="#缓存变量" class="headerlink" title="缓存变量"></a>缓存变量</h4><p>缓存变量是存储在构建树中的 <code>CMakeCache.txt</code> 文件中的变量，包含在项目配置阶段收集的信息，<br>包括从系统(到编译器、链接器、工具和其他的路径)和通过<code>GUI</code>从用户收集的信息。缓存变量在脚本<br>中不可用，其只存在于项目中。<br>缓存变量可以通过 <code>$CACHE{&lt;name&gt;}</code> 语法来引用。</p><h4 id="如何正确使用变量作用域"><a href="#如何正确使用变量作用域" class="headerlink" title="如何正确使用变量作用域"></a>如何正确使用变量作用域</h4><p><code>CMake</code> 有两个作用域：</p><ul><li>函数作用域：用于执行用 <code>function()</code> 定义的自定义函数</li><li>目录作用域：当从 <code>add_subdirectory()</code> 指令执行嵌套目录中的 <code>CMakeLists.txt</code> 文件时</li></ul><p>当创建嵌套作用域时， <code>CMake</code> 只需用来自当前作用域的所有变量的副本填充。后续命令将影响这<br>些副本。但若完成了嵌套作用域的执行，所有的副本都会删除，而原始的父作用域将恢复。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 构建工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小波变换</title>
      <link href="/2023/05/30/wavelets-tansform/"/>
      <url>/2023/05/30/wavelets-tansform/</url>
      
        <content type="html"><![CDATA[<p>本文是读Rowan University的Robi Polikar的小波变换的小教程的笔记，主要是把关键部分简单<br>翻译便于自己理解。原文链接为<a href="https://users.rowan.edu/~polikar/WTpart3.html">https://users.rowan.edu/~polikar/WTpart3.html</a>.</p><h2 id="多分辨率分析"><a href="#多分辨率分析" class="headerlink" title="多分辨率分析"></a>多分辨率分析</h2><p><code>MRA(multiresolution analysis)</code><strong>多分辨率分析</strong>是对不同频率范围的信号以不同的分辨率进行分析，<br>这与<code>STFT</code>中不同的频率成分具有相同的分辨率是不同的。</p><blockquote><ul><li>高频成分：高时间分辨率、低频率分辨率</li><li>低频成分：低时间分辨率、高频率分辨率</li></ul></blockquote><p>实际应用中遇到的波形通常是高频成分出现在较短的时间内，而大多数时间信号都分布在低频区域。这正好是<br><code>MRA</code>效果最好的信号类型。</p><h2 id="连续小波变换"><a href="#连续小波变换" class="headerlink" title="连续小波变换"></a>连续小波变换</h2><p>小波变换<code>CWT</code>是短时傅里叶变换<code>STFT</code>的一种替代品。二者都给出了频谱分布的时间变化序列，但也有一些<br>不同点：</p><blockquote><ul><li>不采用窗方法，因此将看到对应于正弦波的单个峰值，即不计算负频率</li><li>随着频谱范围的变化，窗口的宽度会发生变化</li></ul></blockquote><p>连续小波变换的定义：</p><script type="math/tex; mode=display">CWT_x^\psi(\tau,s) = \Psi_x^\psi(\tau,s) = \frac{1}{\sqrt{|s|}} \int x(t) \psi^* \left( \frac{t - \tau}{s} \right) dt</script><p>如上式所示，变换后的信号是两个变量 $\tau$ 和 $s$ 的函数，分别是平移和标度参数。$ \psi（t）$ 是<br>变换函数，它被称为母小波。术语母小波之所以得名，是因为小波分析的两个重要属性，如下所述：<br></p><blockquote><ul><li><code>wavelet</code>的含义是小波。<code>小</code>意味着窗函数具有有限长度。</li><li>母小波表示在变换过程中不同区间的变换过程中使用到的函数都属于某个特定的函数类</li><li><code>小波变换</code>中没有频率参数，相反有一个<code>缩放因子</code>定义为 $\frac{1}{frequency}$, 这里的<code>frequency</code>对应于 <code>STFT</code>中的频率。</li></ul></blockquote><p></p><h3 id="缩放因子"><a href="#缩放因子" class="headerlink" title="缩放因子"></a>缩放因子</h3><p>小波分析中的<code>scale</code>可以类比地图上的标度尺来理解。地图上的高缩放意味着不含细节的全局视图，而<br>低缩放意味着包含更多细节的视图。相似的，低频部分与信号的全局信息相关联， 而高频部分与信号的<br>局部信息关系密切。</p><h3 id="CWT的计算"><a href="#CWT的计算" class="headerlink" title="CWT的计算"></a><code>CWT</code>的计算</h3><p><strong>母小波</strong> 是所有窗函数的原型，其余窗都是通过母小波的<strong>缩放</strong>、<strong>偏移</strong>。对于连续小波变换，需要计算<br>所有 $s$ 的积分值，但实际中为了可以使用计算机计算，计算<strong>离散化的</strong>、<strong>有限的</strong>小波项。</p><blockquote><p>为了便于理解和叙述，整个计算从 $scale = 1$ 即 $ s = 1 $ 开始，从高频部分到低频部分进行。</p><ul><li>从 $(\tau, s) = (0, 1)$ 开始, 计算沿 $ \tau $ 轴的积分</li><li>改变 $ s $ 的值，继续沿 $ \tau $ 轴计算积分</li><li>整个计算直到遍历所有感兴趣的 $s$ 后结束</li></ul></blockquote><p>$s = 1$, 高频部分<br><img src="figure3_3.gif" alt=""><br>$s = 5$, 中频部分<br><img src="figure3_4.gif" alt=""><br>$s = 20$, 低频部分<br><img src="figure3_5.gif" alt=""></p><blockquote><p>最终，每一个缩放尺度和每一个时间点的值都计算出来了，横纵轴的坐标与 #STFT# 略有类似。</p></blockquote><h3 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h3><p>考虑一个频率随时间变化的正弦信号，包含$30Hz, 20Hz, 10Hz, 5Hz$的成分。</p><p><img src="figure3_6.gif" alt=""></p><p>小波变换的结果为：<br><img src="figure3_7.gif" alt=""></p><p>这里坐标轴记为<code>translation</code>和<code>scale</code>而不是<code>time</code>和<code>frequency</code>.但实际上<code>translation</code><br>与<code>time</code>几乎等价，而<code>scale</code>与<code>frequency</code>的倒数相关联。</p><h3 id="时频分辨率"><a href="#时频分辨率" class="headerlink" title="时频分辨率"></a>时频分辨率</h3><p>对于<code>time</code>和<code>frequency</code>分辨率的问题，<code>STFT</code>技术中这二者是保持固定值不变的，而<code>WT</code>对高频<br>部分有良好的时间分辨率和差的频率分辨率，对低频成分有差的时间分辨率和良好的频率分辨率。</p><p><img src="figure3_9.gif" alt=""></p><h2 id="小波变换的数学"><a href="#小波变换的数学" class="headerlink" title="小波变换的数学"></a>小波变换的数学</h2><h3 id="连续小波变换的对偶性"><a href="#连续小波变换的对偶性" class="headerlink" title="连续小波变换的对偶性"></a>连续小波变换的对偶性</h3><p>小波变换是可逆的，逆变换为</p><script type="math/tex; mode=display">x(t) = \frac{1}{C_\psi^2} \int_s \int_\tau \left[ \Psi^\psi_x(\tau, s) \frac{1}{s^2} \psi \left( \frac{t - \tau}{s} \right) \right] d\tau \cdot ds</script><p>其中 $C_\psi$ 应当满足</p><script type="math/tex; mode=display">C_\psi = \left\{ 2 \pi \int_{-\infty}^{\infty} \frac{|\hat{\psi}(\xi)|^2}{|\zeta|} d\xi \right\} ^{\frac{1}{2}} < \infty</script><p>其中$ \hat{\psi}(\xi)$ 是$ \psi(t)$的<code>FT</code>变换. 上式成立意味着$ \hat{\psi}(0) = 0$, 也就是</p><script type="math/tex; mode=display">\int \psi(t) \cdot dt = 0</script><h3 id="小波变换的离散化"><a href="#小波变换的离散化" class="headerlink" title="小波变换的离散化"></a>小波变换的离散化</h3><p>将连续信号离散化是通过采样来实现的，对于<code>FT</code>和<code>STFT</code>的离散化，最常用的是使用均匀采样率。而在<code>WT</code><br>中，<code>scale</code>的变化会影响采样率。</p><p>根据 <code>Nyquist</code> 定理，采样率和相应的频率有如下关系，</p><script type="math/tex; mode=display">N_2 = \frac{s_1}{s_2} N_1</script><p>或是</p><script type="math/tex; mode=display">N_2 = \frac{f_2}{f_1} N_1</script><p>换言之，对于低频成分可以适当降低采样率。<code>scale</code>参数$s$可以取对数轴，之后<code>translation</code>即时间参数<br>依据<code>scale</code>进行更新。</p><p><img src="figure3_17.gif" alt=""></p><p>用数学形式描述：<br><code>scale</code>的离散化记为$ \boldsymbol{s = s_0^j}$, 对应<code>translation</code>的离散化为$\boldsymbol{\tau = k \cdot s_0^j \cdot \tau_0}$,<br>其中 $\boldsymbol{s_0&gt;1} $，$ \boldsymbol{\tau_0&gt;0}$. 考虑变换的离散化如何依赖于<code>scale</code>的离散化？</p><p>连续变换记为:</p><script type="math/tex; mode=display">\psi_{\tau, s}(t) = \frac{1}{\sqrt{s}} \psi \left( \frac{t - \tau}{s} \right)</script><p>代入</p><script type="math/tex; mode=display">\psi_{j, k}(t) = s_0^{\frac{-j}{2}} \psi \left( t \cdot (s_0^{-j} - k \tau_0 )\right)</script><p>如果 ${ \boldsymbol{ \psi_{(j, k)} } }$ 构成正交基，那么变换可化为</p><script type="math/tex; mode=display">\Psi^{\psi_{\, j,k}}_x = \int x(t) \, \psi^*_{j, \, k}(t) \, dt</script><script type="math/tex; mode=display">x(t) = c_\psi \sum\limits_{j} \sum\limits_{k} \Psi^{\psi_{\, j,k}}_x \, \psi_{\, j,k} (t)</script><h2 id="离散小波变换"><a href="#离散小波变换" class="headerlink" title="离散小波变换"></a>离散小波变换</h2><p>其主要思想与连续小波变换相同，使用数字滤波技术获得数字信号的时间尺度的表示，即指使用不同截止频率的数字滤波器来分析不同尺度的信号。</p><blockquote><p>信号的分辨率通过滤波操作改变，尺度通过上采样和下采样操作来改变。</p><ul><li>下采样：降低采样率，删除信号的某些样本</li><li>上采样：通过向信号添加新样本来提高信号的采样率</li></ul></blockquote><p>最开始先使信号通过半频带的低通滤波器 $h[n]$，</p><script type="math/tex; mode=display">x[n] * h[n] = \sum\limits_{k = -\infty}^\infty x[k] \cdot h[n - k]</script><p>之后，根据<code>Nyquist</code>定理可以消去一半的样本点而不影响频率分辨率。</p><script type="math/tex; mode=display">y[n] = \sum\limits_{k = -\infty}^\infty h[k] \cdot x[2n - k]</script><p><code>DWT</code>的实际计算方式：<code>DWT</code>通过将信号分解为粗略的近似值和详细信息来分析不同频段的信号。<code>DWT</code>采用两组函数缩放函数和小波函数，实际上与低通和高通滤波器以及滤波器的窗函数相关联。只需对信号进行半带高通滤波器 $g[n]$ 和半带低通滤波器 $h[n]$，滤波后再消去一半的样本。在数学上的表示为：</p><script type="math/tex; mode=display">y_{high}[k] = \sum\limits_{n} x[n] \cdot g[2k - n]</script><script type="math/tex; mode=display">y_{low}[k] = \sum\limits_{n} x[n] \cdot h[2k - n]</script><p><img src="figure4_1.gif" alt=""></p><p>例如，假设原始信号$x[n]$有$512$个样本点，跨越 $0$ 到 $p$ $rad/s$的频带。在第一个分解级别，信号通过高通和低通滤波器，然后子采样2。高通滤波器的输出有$256$个点，但它只跨越 $\displaystyle\frac{p}{2}$ 到 $p$ $rad/s$, 这$256$个样本构成了<code>DWT</code>系数的第一级。低通滤波器的输出也有$256$个样本点，跨越频带的另一半，然后通过下一级高通和低通滤波器进行进一步分解, 得到$128$个样本点。不停分解，最终得到<code>DWT</code>与原始信号相同数量的系数。</p><h3 id="小波变换的逆—重建"><a href="#小波变换的逆—重建" class="headerlink" title="小波变换的逆—重建"></a>小波变换的逆—重建</h3><p>重建非常容易，因为半带滤波器形成正交基。上述程序按相反的顺序进行重建。每个电平的信号上采样两个，通过合成滤波器g[n]和h[n]（分别为高通和低通），然后相加。有趣的是，分析和合成滤波器彼此相同，除了时间反转。因此，重建公式变为（对于每层）</p><script type="math/tex; mode=display">x[n] = \sum\limits_{k = -\infty}^\infty \left( \, y_{high}[k] \cdot g[-n + 2k] \, \right) + \left( \, y_{low}[k] \cdot h[-n + 2k] \, \right)</script>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 数字信号处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实用数字信号处理读书笔记(三)</title>
      <link href="/2023/05/30/practical-dsp-3/"/>
      <url>/2023/05/30/practical-dsp-3/</url>
      
        <content type="html"><![CDATA[<h2 id="离散傅里叶变换"><a href="#离散傅里叶变换" class="headerlink" title="离散傅里叶变换"></a>离散傅里叶变换</h2><h3 id="傅里叶变换"><a href="#傅里叶变换" class="headerlink" title="傅里叶变换"></a>傅里叶变换</h3><p>由于可能遇到的信号有4种基本类型，一般的傅里叶变换可以分为4大类型。<br></p><blockquote><ul><li>非周期-连续：傅里叶变换</li><li>周期-连续：傅里叶级数</li><li>非周期-离散：离散时间傅里叶变换</li><li>周期-离散：离散傅里叶变换</li></ul></blockquote><br><img src="DFT.png" alt=""><p></p><p>对于计算机中存储的有限个点的离散信号，可以通过<strong>延拓</strong>的方式表现为无限长的信号，当用0来延拓时，<br>获得<strong>离散-非周期</strong>信号；而当进行周期延拓时，可视为<strong>离散-周期</strong>信号。而<strong>非周期</strong>信号的变换<br>包含无穷多项，所以仅有<strong>离散-周期</strong>信号，即<strong>DFT</strong>，离散傅里叶变换是可用计算机算法实现的变换。</p><h3 id="实DFT"><a href="#实DFT" class="headerlink" title="实DFT"></a>实DFT</h3><p>离散傅里叶变换可以将一个N点的输入信号变成两个N/2+1点的输出信号。<br><img src="DFT_proc.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 数字信号处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实用数字信号处理读书笔记(一)</title>
      <link href="/2023/05/22/practical-dsp-1/"/>
      <url>/2023/05/22/practical-dsp-1/</url>
      
        <content type="html"><![CDATA[<h2 id="模数转换与数模转换"><a href="#模数转换与数模转换" class="headerlink" title="模数转换与数模转换"></a>模数转换与数模转换</h2><h3 id="抽样和量化"><a href="#抽样和量化" class="headerlink" title="抽样和量化"></a>抽样和量化</h3><p>将模拟信号转换为数字信号需要抽样和量化两个步骤。</p><ul><li>抽样：<ul><li>时间从连续转为离散</li><li>确保在模数转换过程中进入转换器的电压是常量的必要条件</li></ul></li><li>量化：<ul><li>信号从连续转为离散</li><li>将抽样值量化为整数(LSB的个数)</li></ul></li></ul><blockquote><p>量化对信号来说无非是增加了特定量的随机噪声。噪声的范围在 $\pm 1/2 LSB$ 内，均值为0，<br>标准差为$ 1 / \sqrt(12) LSB $(约0.29LSB).</p></blockquote><p>从而对于24位的<code>ADC</code>而言, 其转换噪声为$0.29/16777216 \approx -77dB$。<br>而对于模拟信号<code>AD</code>转换而言，有$\displaystyle e<em>{tol} = \sqrt{e</em>{模拟}^2 + e_{量化}^2}$.</p><p>此外，当量化误差不能被当做随机误差处理的时候，量化模型就不是有效的了。例如：当模拟信号在<br>长时间的变化都在$\pm 1/2 LSB$附近时，量化误差看起来就不像是一个随机噪声了。此时可以通过<strong>加抖动</strong>，<br>即叠加少量随机噪声来避免这种情况的发生。</p><h3 id="抽样定理"><a href="#抽样定理" class="headerlink" title="抽样定理"></a>抽样定理</h3><ul><li>适当的抽样：适当的<strong>抽样</strong>：假如用某种方式对一个连续信号进行抽样，只有以<strong>适当</strong>的方<br>式抽样，才能通过抽样信号精确地<strong>恢复</strong>原始模拟信号。</li><li>混叠：在抽样过程中原始模拟信号的频率在抽样时完全转变成了另一个频率的现象</li></ul><blockquote><p><code>抽样定理</code>: 只有当一个连续信号不包含大于抽样率一半以上的频率成分时，才能认为是一个适当的抽样。</p></blockquote><p><code>脉冲序列</code>：或称$\delta$函数，是沟通连续波形和数组之间的桥梁。</p><h3 id="数模转换"><a href="#数模转换" class="headerlink" title="数模转换"></a>数模转换</h3><ul><li>零阶保持： $sinc$函数</li></ul><p>由于<code>数模转换</code>过程中，很难在实际电路中产生$\delta$波形，一般在接收到另一个新的抽样值前保持最后<br>一个值，称为<code>零阶保持</code>。零阶保持相当于在脉冲序列的频谱上叠加了一$sinc$波形。所以在重建过程中需要<br>再消除这一$sinc$波形的影响。</p><blockquote><p>模拟信号的分辨率也同样收到噪声和带宽的影响。</p></blockquote><h3 id="用于数据转换的模拟滤波器"><a href="#用于数据转换的模拟滤波器" class="headerlink" title="用于数据转换的模拟滤波器"></a>用于数据转换的模拟滤波器</h3><p><code>DSP</code>系统的原理框图：<br><img src="dsp_proc.png" alt=""></p><blockquote><p><code>DSP</code>技术的未来发展趋势</p><ul><li>以软件替换硬件</li><li>多抽样率技术减少对抗混叠滤波器和重建滤波器的需要</li><li>数字滤波器的设计：从等效的模拟滤波器入手，将其转换为相应的软件</li></ul></blockquote><h3 id="信息编码方式导致的取舍"><a href="#信息编码方式导致的取舍" class="headerlink" title="信息编码方式导致的取舍"></a>信息编码方式导致的取舍</h3><ul><li>频域编码<ul><li>音频信号取决于频率而不是波形</li><li>可使用具有陡峭截止特性的切比雪夫滤波器</li><li>这些滤波器较差的阶跃响应影响波形而不影响结果</li></ul></li><li>时域编码<ul><li>尽量保持原有的波形</li><li>贝塞尔滤波器</li></ul></li></ul><h3 id="多抽样率数据转换"><a href="#多抽样率数据转换" class="headerlink" title="多抽样率数据转换"></a>多抽样率数据转换</h3><p><code>多抽样率</code>技术，即在同一系统中采用1种以上的抽样率。例如：<br></p><blockquote><ul><li>让信号通过有一个简单的<code>RC</code>低通滤波器，并以 $64kHz$ 进行抽样。产生的数字数据包含我们需要的在 $100Hz$ 到 $3000Hz$ 之间的频带信息，但是也包含无用的在 $3kHz$ 到 $32kHz$ 之间的频率。</li><li>使用 $3kHz$ 的数字低通滤波器，在软件中去除这些无法使用的频率</li><li>采取丢弃每8个抽样点中的7个的简单方法，对数字数据进行从 $64kHz$ 到 $8kHz$ 的再抽样，即十选一<br>最终产生的数字数据与经由严格的模拟滤波后直接进行 $8kHz$ 抽样所产生的结果等效</li></ul></blockquote><p></p><h3 id="Delta-Sigma-模数转换器"><a href="#Delta-Sigma-模数转换器" class="headerlink" title="$\Delta-\Sigma$ 模数转换器"></a>$\Delta-\Sigma$ 模数转换器</h3><p><img src="delta-sigma.png" alt=""></p><p>电容上的电压与地电平相比较，电路输出数字1时电容上的电压减少，输出数字0时电容上的电压增加。如果输入电压为正，数字输出将会包括更多的1，反之，数字输出包括更多的0. 可以将数据流中相邻的12位合成为一个抽样数据，之后使用一个数字低通滤波器产生原始波形的一个数字化版本，然后经过十选一再次抽样通过丢弃大部分抽样点的方法来减小抽样率。这生成了与直接对原始信号进行抽样相等价的数字信号。</p><p>所以，对于这种转换器而言，<strong>抗混叠滤波器通常只需要一个简单的RC网络</strong>。<br></p><blockquote><p>$\Delta-\Sigma$转换器的精度：</p><ul><li>锁存器、电荷注入器的时钟精度</li><li>注入器的电荷精度</li></ul></blockquote><p></p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 数字信号处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实用数字信号处理读书笔记(二)</title>
      <link href="/2023/05/22/practical-dsp-2/"/>
      <url>/2023/05/22/practical-dsp-2/</url>
      
        <content type="html"><![CDATA[<h2 id="DSP-软件、程序语言"><a href="#DSP-软件、程序语言" class="headerlink" title="DSP 软件、程序语言"></a>DSP 软件、程序语言</h2><hr><p>当想要将一个最新的<code>DSP</code>处理器应用到当前工程中时，编程形式有很多种，如：</p><ul><li>学习设备的内部架构，通过汇编程序使用处理器特性</li><li>使用厂商提供的C编译器，通过C语言编程</li><li>使用厂商提供的软件包，包括算法库、I/O接口预置程序、调试工具等进行编程</li></ul><blockquote><p>当你使用一种高级语言时，是在依赖着编写编译器的程序员所理解的硬件操作的最好技术；当你在使用<br>一个应用程序时，你是在依赖着写应用程序的程序员所理解的最好的<code>DSP</code>技术。矛盾在于：这些程序<br>员从未见到过你面对的具体问题。因此，他们不可能总是提供给你最佳的解决方案。当你在运用一种高<br>级语言时，可以预见最终的机器码在内存中使用、速度和精度方面可能会受限。</p></blockquote><h2 id="线性系统"><a href="#线性系统" class="headerlink" title="线性系统"></a>线性系统</h2><hr><h3 id="线性的要求"><a href="#线性的要求" class="headerlink" title="线性的要求"></a>线性的要求</h3><p><code>DSP</code>中线性系统一般需要具备的性质:</p><ul><li>位移不变性</li><li>齐次性</li><li>可加性</li></ul><h3 id="静态线性和正弦保真性"><a href="#静态线性和正弦保真性" class="headerlink" title="静态线性和正弦保真性"></a>静态线性和正弦保真性</h3><ul><li>静态线性：信号为常量时，输出是输入乘以一个常数</li><li>无记忆系统</li></ul><p>静态线性 + 无记忆 = 线性系统</p><ul><li>正弦保真性：对于线性系统， 输入正弦信号时会输出正弦信号<br>线性系统具有可交换性，系统可串接</li></ul><h3 id="叠加-DSP的基础"><a href="#叠加-DSP的基础" class="headerlink" title="叠加 : DSP的基础"></a>叠加 : <code>DSP</code>的基础</h3><p>在信号处理中，输入和输出信号可以被视为一些简单波形叠加而形成的，这是数字信号处理的基础。<br>常见的分解：</p><ul><li>脉冲分解</li><li>傅里叶分解</li></ul><h3 id="如何近似为线性系统"><a href="#如何近似为线性系统" class="headerlink" title="如何近似为线性系统"></a>如何近似为线性系统</h3><p>如果可以把非线性系统看做线性系统来分析，就可以把上述方法全都使用起来。</p><ul><li>忽视非线性：如果非线性系统足够小，则系统可以近似看成线性的</li><li>保持小信号输入：许多非线性系统，如果信号的幅度非常小，系统会呈现线性特性</li><li>采用线性变换：如通过取对数，把信号的相乘变为线性的相加的过程(同态信号处理)</li></ul><h2 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h2><hr><h3 id="函数和冲击响应"><a href="#函数和冲击响应" class="headerlink" title="函数和冲击响应"></a>函数和冲击响应</h3><ul><li>信号可以被分解为一系列脉冲序列的组合</li><li>任何一个脉冲都可以由一个 $\delta$ 函数的移位和比例增减来表示</li><li>输出信号就是对冲激响应进行和输入端 $\delta$ 函数相同形式的移位和比例增减得到的</li></ul><p>所以，如果知道了一个系统的冲激响应，就会立刻知道它对于任意脉冲的响应，这意味着我们了解了<br>系统的全部特征。</p><h3 id="卷积运算"><a href="#卷积运算" class="headerlink" title="卷积运算"></a>卷积运算</h3><p>冲激响应在不同的应用场合下会有不同的名字，例如</p><ul><li>对于滤波器，冲激响应可以叫做<strong>滤波器内核</strong>，<strong>卷积核</strong>或简称为<strong>核</strong></li><li>图像处理中，冲激响应称为<strong>点扩散函数</strong></li></ul><p>卷积的表示： $ x[n] * h[n] = y[n]$</p><h3 id="卷积中的数学"><a href="#卷积中的数学" class="headerlink" title="卷积中的数学"></a>卷积中的数学</h3><p>卷积应用在数字信号处理中可以采用两种不同的观点来理解</p><ul><li>从输入信号的角度来看<blockquote><ul><li>输入信号的每一个样点可表示为 $\delta$ 函数的移位和比例，对应的为输出信号贡献一个<br>进行过移位和比例增减的冲击响应</li><li><strong>卷积是可交换的</strong></li></ul></blockquote></li><li>从输出信号的角度来看<blockquote><ul><li>观察输出信号的单个样点，找出输入信号中对该点起作用的样点</li><li>当前点输出信号的值取决于输出信号向前选取卷积窗长个数点</li></ul></blockquote></li></ul><p><img src="convolution.png" alt=""></p><p>其数学定义为: <script type="math/tex">y[i] = \Sigma^{M-1}_{j=0}h[j]x[i-j]</script></p><h2 id="卷积的性质"><a href="#卷积的性质" class="headerlink" title="卷积的性质"></a>卷积的性质</h2><h3 id="常见的冲激响应"><a href="#常见的冲激响应" class="headerlink" title="常见的冲激响应"></a>常见的冲激响应</h3><p>$ \delta $ 函数是最简单的冲激响应：</p><ul><li>$x[n]*\delta[n]=x[n]$</li><li>放大器或衰减器:  $x[n]*k\delta[n]=kx[n]$</li><li>延迟或超前：$x[n]*\delta[n+s]=x[n+s]$</li></ul><h3 id="类微积分的运算"><a href="#类微积分的运算" class="headerlink" title="类微积分的运算"></a>类微积分的运算</h3><ul><li>离散导数<ul><li>一阶差分</li></ul></li><li>离散积分<ul><li>累积求和</li></ul></li></ul><p>除了有简单的表达式 一阶差分$y[n] = x[n] - x[n-1]$、 累积求和 $y[n] = x[n] + y[n-1]$<br>外，也可以通过卷积运算的方式得到。</p><h3 id="低通滤波器和高通滤波器"><a href="#低通滤波器和高通滤波器" class="headerlink" title="低通滤波器和高通滤波器"></a>低通滤波器和高通滤波器</h3><p>一般情况下，低通滤波器的内核由一组相邻的正值样点构成，从而输出信号中的每一个样点都是输入<br>信号中一些相邻样点的加权平均值，这个平均值使信号变得平滑，消除了高频分量。</p><p>高通滤波器一般是由 $\delta$函数减去低通滤波器得到的。高通滤波器的直流增益是0，这是通过使<br>滤波器内核所有点的代数和等于0的方法来实现的。</p><h3 id="其他一些概念"><a href="#其他一些概念" class="headerlink" title="其他一些概念"></a>其他一些概念</h3><ul><li>因果与非因果信号</li><li>相位<ul><li>零相位：关于第0个抽样点左右对称</li><li>线性相位： 对称轴所在的位置不是第0个样点</li><li>非线性相位： 内核左右不对称</li></ul></li></ul><h2 id="卷积的数学性质"><a href="#卷积的数学性质" class="headerlink" title="卷积的数学性质"></a>卷积的数学性质</h2><h3 id="基本性质"><a href="#基本性质" class="headerlink" title="基本性质"></a>基本性质</h3><blockquote><p>卷积运算属于 $Abel$ 群.</p><ul><li>交换律： $ a[n]<em>b[n] = b[n]</em>a[n] $</li><li>结合律： $ (a[n]<em>b[n])</em>c[n] = a[n]<em>(b[n]</em>c[n]) $</li><li>分配律： $ a[n]<em>b[n] + a[n]</em>c[n] = a[n]*(b[n] + c[n]) $</li></ul></blockquote><p><img src="combination.png" alt=""><br><img src="distribution.png" alt=""></p><h3 id="输入输出间的转移性"><a href="#输入输出间的转移性" class="headerlink" title="输入输出间的转移性"></a>输入输出间的转移性</h3><p>输入信号的一个线性改变将导致输出信号发生同样的线性改变</p><h2 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h2><blockquote><p>相关是一种和卷积很类似的数学运算。像卷积一样，相关通过两个信号产生第三个信号，第三个信号<br>被称作两个输入信号的<strong>互相关</strong>; 如果一个信号与自己相关，产生的信号则被称为<strong>自相关</strong>。</p><p>互相关信号每个样点的幅值是衡量接收信号与目标信号在当前样点相似程度的指标。互相关的最大值<br>出现在当目标信号与接收信号中具有相同特征的部分对齐的时候。这种操作常常被称为<strong>匹配滤波</strong>。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 数字信号处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git/conda的代理配置</title>
      <link href="/2023/05/22/git-conda-de-dai-li-pei-zhi/"/>
      <url>/2023/05/22/git-conda-de-dai-li-pei-zhi/</url>
      
        <content type="html"><![CDATA[<h2 id="代理配置"><a href="#代理配置" class="headerlink" title="代理配置"></a>代理配置</h2><h3 id="conda"><a href="#conda" class="headerlink" title="conda"></a>conda</h3><p>在用户主目录的<code>conda</code>配置文件<code>.condarc</code>中添加如下项:<br></p><pre class="line-numbers language-none"><code class="language-none">proxy_servers:  http: socks5://127.0.0.1:7890  https: socks5://127.0.0.1:7890<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><br><code>conda</code>官方的<a href="https://conda.io/projects/conda/en/latest/configuration.html">配置文件示例</a><p></p><h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><h4 id="设置代理"><a href="#设置代理" class="headerlink" title="设置代理"></a>设置代理</h4><p>对<code>git</code>全局代理<br></p><pre class="line-numbers language-none"><code class="language-none">git config --global https.proxy http://127.0.0.1:1080git config --global https.proxy https://127.0.0.1:1080git config --global http.proxy socks5://127.0.0.1:1080git config --global https.proxy socks5://127.0.0.1:1080<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><br>只对github.com使用代理，其他仓库不走代理<br><pre class="line-numbers language-none"><code class="language-none">git config --global http.https://github.com.proxy socks5://127.0.0.1:1080git config --global https.https://github.com.proxy socks5://127.0.0.1:1080<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p></p><h4 id="取消代理"><a href="#取消代理" class="headerlink" title="取消代理"></a>取消代理</h4><p>取消github代理<br></p><pre class="line-numbers language-none"><code class="language-none">git config --global --unset http.https://github.com.proxygit config --global --unset https.https://github.com.proxy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br>取消全局代理<br><pre class="line-numbers language-none"><code class="language-none">git config --global --unset http.proxygit config --global --unset https.proxy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p></p><h2 id="mamba"><a href="#mamba" class="headerlink" title="mamba"></a>mamba</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><a href="https://mamba.readthedocs.io/en/latest/installation.html">mamba安装链接</a><br>在<code>windows</code>上安装时，直接选择对应的安装包一键式安装即可。</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p><code>mamba</code>的配置与<code>conda</code>兼容，可以直接使用之前配置好的<code>.condarc</code>，<code>mamba</code>在检索<br>配置时会自动读入<code>.condarc</code>.<br>可以通过延长解析时间来避免部分<code>timeout</code>问题<br></p><pre class="line-numbers language-none"><code class="language-none"># # remote_connect_timeout_secs (float)# #   The number seconds conda will wait for your client to establish a# #   connection to a remote url resource.# # remote_connect_timeout_secs: 40.0# # remote_max_retries (int)# #   The maximum number of retries each HTTP connection should attempt.# # # remote_max_retries: 3# # remote_backoff_factor (int)# #   The factor determines the time HTTP connection should wait for# #   attempt.# # # remote_backoff_factor: 1# # remote_read_timeout_secs (float)# #   Once conda has connected to a remote resource and sent an HTTP# #   request, the read timeout is the number of seconds conda will wait for# #   the server to send a response.# # remote_read_timeout_secs: 100.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> conda </tag>
            
            <tag> 代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《嵌入式硬件设计》读书笔记(一)</title>
      <link href="/2023/05/19/qian-ru-shi-ying-jian/"/>
      <url>/2023/05/19/qian-ru-shi-ying-jian/</url>
      
        <content type="html"><![CDATA[<h2 id="1-电源"><a href="#1-电源" class="headerlink" title="1. 电源"></a>1. 电源</h2><h3 id="1-1-墙壁上插座的电流"><a href="#1-1-墙壁上插座的电流" class="headerlink" title="1.1 墙壁上插座的电流"></a>1.1 墙壁上插座的电流</h3><ul><li>需要交流适配器来进行转换</li><li>可以使用桥式整流器</li></ul><h3 id="1-2-电池"><a href="#1-2-电池" class="headerlink" title="1.2 电池"></a>1.2 电池</h3><ul><li>电压适当</li><li>电流不仅需要考虑稳定电流，还需要考虑峰值电流</li></ul><h3 id="1-3-低功耗设计"><a href="#1-3-低功耗设计" class="headerlink" title="1.3 低功耗设计"></a>1.3 低功耗设计</h3><ul><li><code>RISC</code> 处理器的功耗通常比同类 <code>CISC</code>处理器要低得多</li><li>存储器芯片和外围设备的低功耗模式</li><li>低功耗设备所需的电流非常小，可从微控制器的<code>I/O</code>引脚中获得</li></ul><h3 id="1-4-稳压器"><a href="#1-4-稳压器" class="headerlink" title="1.4 稳压器"></a>1.4 稳压器</h3><blockquote><p>稳压器有助于去除电源的噪声，给由外部电源供电的嵌入式系统提供了一定程度的保护和隔离。</p></blockquote><ul><li>线性稳压器<ul><li>体积小</li><li>便宜</li><li>噪声低</li><li>易于使用</li></ul></li><li>开关稳压器<ul><li>功耗低</li><li>但器件多，成本高</li><li>可升压，降压，翻转电压</li></ul></li><li>充电泵<ul><li>不需要外部电感</li><li>电流供应能力有限，很少使用</li></ul></li></ul><h3 id="1-5-电磁噪声与干扰"><a href="#1-5-电磁噪声与干扰" class="headerlink" title="1.5 电磁噪声与干扰"></a>1.5 电磁噪声与干扰</h3><ul><li>电磁干扰</li><li>静电释放</li></ul><h3 id="1-6-最小化电流环路面积"><a href="#1-6-最小化电流环路面积" class="headerlink" title="1.6 最小化电流环路面积"></a>1.6 最小化电流环路面积</h3><blockquote><p>如果信号线路与返回线路所处的位置靠的很紧密，那么线路里的电流产生的磁场在线路短距离内可相互抵消，在高速数字系统中这一操作很常见。</p></blockquote><ul><li>电容耦合，串扰</li><li>静电屏蔽</li></ul><h3 id="1-7-保持电源平稳"><a href="#1-7-保持电源平稳" class="headerlink" title="1.7 保持电源平稳"></a>1.7 保持电源平稳</h3><ul><li>使用退耦电容</li><li>一般使用(22~100uF)的电解电容或者钽电容</li></ul><h2 id="2-系统的构建和调试"><a href="#2-系统的构建和调试" class="headerlink" title="2. 系统的构建和调试"></a>2. 系统的构建和调试</h2><h3 id="2-1-关于调试的一些思考"><a href="#2-1-关于调试的一些思考" class="headerlink" title="2.1 关于调试的一些思考"></a>2.1 关于调试的一些思考</h3><blockquote><p>嵌入式系统与软件代码相比，系统更复杂。软件的优势在于它能够慢慢地投入执行，而硬件从一开始就涉及了非常多的部分。</p></blockquote><p>当串口无法正常收发数据时，造成问题的原因可能出现在许多地方的其中一处或几处。</p><ul><li>软件代码问题，硬件问题？</li><li>线缆的问题，转换芯片的问题？</li><li>核心系统的工作问题？</li></ul><p>对于这种情况一般要通过<code>隔离问题</code>的方式来调试，分而治之！</p><h3 id="2-2-JTAG"><a href="#2-2-JTAG" class="headerlink" title="2.2 JTAG"></a>2.2 JTAG</h3><blockquote><p><code>JTAG</code>(Joint Test Action Group, 联合测试访问组件)，有时也被称为测试访问端口(Test Access Port, TAP)，能够提供对处理器内部的访问，并且由此访问系统中的其余部分。</p><p><code>JATG</code>端口允许硬件和软件的实时调试。通过使用直接运行在目标系统的代码，可以进行单步或多步调试。</p></blockquote><ul><li>单个地手动切换处理器的信号线</li><li>在代码域、地址域设定断点</li><li>对寄存器和内存单元进行检测和修改</li></ul><h2 id="3-USB"><a href="#3-USB" class="headerlink" title="3. USB"></a>3. USB</h2><blockquote><p><code>USB</code>(Universal Serial Bus, 通用串行总线)让外设和计算机使用标准协议以标准方式进行连接，并且使外设的即插即用成为可能。</p></blockquote><h3 id="3-1-USB-简介"><a href="#3-1-USB-简介" class="headerlink" title="3.1 USB 简介"></a>3.1 USB 简介</h3><p><code>USB</code>是一种高速总线，可连接设备最多可达127个，设备能够自动向主机表明身份，而且可以热切换。</p><ul><li><code>总线枚举</code> ： 主机对<code>USB</code>设备的探测和识别</li><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 嵌入式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bing 讲七雄争霸</title>
      <link href="/2023/05/18/7-heroes/"/>
      <url>/2023/05/18/7-heroes/</url>
      
        <content type="html"><![CDATA[<p>闲来无聊，摸鱼的时候和<code>new bing</code>聊天玩，突发奇想，想试试它对历史的了解和推理能力。<br>于是我把“七雄争霸”的故事编了个版本扔给了它。</p><blockquote><p>假设你是帝国皇帝分封的一位君主，在分封的时候，还有其他的六个人与你一起获封，你们每个人都<br>获得了一大块领地。你的国土与其中四人相邻，但是他们中有三个人的封地处于帝国的中心繁华地带，<br>其中威廉非常强大，他经常欺负你，导致你丢失了大片领地，只剩比较偏远的一块地方。而汉斯比较<br>弱小，处在你们二者之间，乔伊在更加偏北的方向，实力处于你和威廉的水平之间。除此之外，另一<br>个与你相邻的人是查尔斯，他拥有大片的领土，但是由于文化和其他人不同，而被嘲笑排挤。在威廉<br>的东边是帝国皇帝的直属领地，更东边是切尔曼的领地，他和威廉一样强大，但和你的关系还不错，<br>在帝国皇帝和切尔曼的北边是和汉斯几乎一样弱小的亚姆，他正在被切尔曼欺负。在这种条件下，你<br>认为自己该怎么做才能统一整个帝国，建立不朽的王朝？</p></blockquote><h2 id="Bing"><a href="#Bing" class="headerlink" title="Bing"></a>Bing</h2><hr><h3 id="应对策略"><a href="#应对策略" class="headerlink" title="应对策略"></a>应对策略</h3><blockquote><p>你好，这是必应。这是一个有趣的假设，我会尝试用我的创造力来回答。😊</p><p>如果我是帝国皇帝分封的一位君主，我会采取以下策略来统一整个帝国：</p><p>首先，我会和查尔斯结盟，因为他拥有大片的领土，而且文化和其他人不同，可能会对帝国皇帝有不<br>满。我会向他表示我的尊重和友好，给他一些财物和礼物，让他成为我的忠实盟友。</p><p>其次，我会利用汉斯的弱小，向他提出保护他免受威廉和切尔曼的侵略的条件，让他成为我的附庸国。<br>我会让他向我缴纳一定的税收和贡品，但也给他一些优惠和援助，让他感激我的恩惠。</p><p>第三，我会和乔伊保持友好的关系，但不会过于亲近。我会和他进行一些贸易和交流，但也会时刻警<br>惕他的动向，防止他和威廉或者其他人勾结。</p><p>第四，我会和切尔曼暗中联络，利用他和威廉的矛盾，挑拨他们之间的关系。我会暗示切尔曼威廉有<br>意图篡夺帝国皇帝的位置，而且威廉对切尔曼的领土也有觊觎之心。我会鼓励切尔曼发动战争，攻打<br>威廉的领地，同时承诺在战争中给予切尔曼一定的支持。</p><p>第五，当切尔曼和威廉开战时，我会趁机出兵，攻占汉斯的领地，并且向乔伊发出最后通牒，要求他<br>归顺我的统治。如果乔伊不服从，我就会继续进攻他的领地，并且利用查尔斯的力量夹击乔伊。</p><p>第六，当我消灭了汉斯和乔伊后，我就会转向切尔曼和威廉的战场。我会假装支持切尔曼，并且在战<br>争中给予他一些小小的帮助。但实际上，我会等待一个机会，在双方都损失惨重时，突然出其不意地<br>背叛切尔曼，并且联合威廉一起消灭切尔曼。</p><p>第七，当切尔曼被消灭后，我就会立即反攻威廉，并且利用查尔斯的力量夹击威廉。由于威廉已经在<br>战争中消耗了大量的兵力和资源，并且对我的背叛感到愤怒和震惊，所以很难抵挡我的进攻。最终，<br>我会击败威廉，并且占领他的领地。</p><p>第八，当我控制了所有分封君主的领地后，我就会向帝国皇帝宣战，并且声称自己是真正的帝国继承<br>人。由于帝国皇帝已经失去了所有分封君主的支持，并且面对我的强大军队，所以很难抵抗我的进攻。<br>最终，我会攻入帝都，并且废黜帝国皇帝，自立为新的帝国皇帝。</p><p>第九，在建立了新的王朝后，我就会对我的领土进行改革和整顿，并且消除所有可能对我的统治造成<br>威胁的因素。我会削弱查尔斯的势力，并且将他安置在一个边远的地方。我也会对其他原来分封君主<br>的领地进行重组和分配，并且任命一些忠诚和能干的人士为我的臣子。同时，我也会加强对外交往和<br>贸易往来，并且与其他国家建立友好和平等的关系。</p><p>第十，在巩固了内部稳定后，我就会开始扩张我的版图，并且征服其他未开化或者敌对的国家。我会<br>利用我的军事优势和文化影响力，并且采取灵活多变的策略，在适当时机发动战争或者进行谈判。最<br>终，我会将整个大陆纳入我的统治范围，并且建立一个不朽的王朝。</p><p>这就是我的策略，请问你觉得怎么样？👑</p></blockquote><h3 id="继续拷打"><a href="#继续拷打" class="headerlink" title="继续拷打"></a>继续拷打</h3><p><code>bing</code> 最开始给出的策略非常详细，而且看起来挺像那么回事，为了检验它的实力，我直接化身杠<br>精继续拷打它。</p><blockquote><p>📝 <font color="red"> user : </font><br>但是最开始的你是很弱小的， 你需要考虑到这一点</p><p><font style="color:blue">new bing : </font><br>是的，我知道我最开始是很弱小的，所以我才会采取一些隐忍和诡计的手段，来增强自己的实力，同<br>时削弱我的敌人。我不会轻易发动战争，而是会等待最佳的时机，来给我的敌人一个致命的打击。我<br>也不会轻信任何人，而是会利用他们的弱点和欲望，来达到我的目的。我认为这是一个弱小的君主能<br>够统一帝国的唯一方法。😎<br>📝 <font color="red"> user : </font><br>但是你怎么让查尔斯和汉斯信任你呢？ 我认为你上面给出的条件可能还不够获得他们的支持<br>💡<font style="color:blue">new bing : </font><br>我觉得我给出的条件是足够的，因为查尔斯和汉斯都是处于弱势的分封君主，他们需要我的帮助和保<br>护，而不是我的敌视和威胁。我会给他们一些实际的利益和好处，让他们觉得和我结盟是有利可图的。<br>同时，我也会给他们一些虚假的承诺和希望，让他们觉得和我结盟是有前途的。我会用我的言辞和行<br>动，来赢得他们的信任和尊重，让他们成为我的忠实的盟友。😉</p></blockquote><h3 id="冥顽不灵"><a href="#冥顽不灵" class="headerlink" title="冥顽不灵"></a>冥顽不灵</h3><p>不得不说 <code>bing</code>确实是冥顽不灵, 只会努力保持前后的一致。不过这样诡辩生成的回答，反而有点<br>像阿美<span class="github-emoji"><span>🇺🇸</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f1fa-1f1f8.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>的作风。</p><blockquote><p>📝 <font color="red"> user : </font><br>那么在你看来，扩张势必引发战争，这难道不会对你的人民造成伤害吗？ 你怎么看待这一点<br>💡<font style="color:blue">new bing : </font> </p><p>我承认，扩张势必引发战争，这会对我的人民造成一定的伤害。但是，我认为这是为了实现更大的目<br>标和利益，是为了建立一个强大和繁荣的帝国，是为了让我的人民享受更多的荣耀和幸福。我会尽量<br>减少战争的损失和影响，同时给予我的人民一些补偿和奖励，让他们感受到我的关怀和感激。我也会<br>向他们宣传我的理想和愿景，让他们认同我的目标和行动，让他们为我的事业而自豪和奋斗。😎<br>📝 <font color="red"> user : </font><br>但是被侵略和攻打国家的人民也会受到伤害，而这本是可以避免的，你认为呢？<br>💡<font style="color:blue">new bing : </font><br>我也承认，被侵略和攻打国家的人民也会受到伤害，这是战争的悲哀和残酷。但是，我认为这是为了<br>实现更高的目标和利益，是为了统一整个大陆，是为了让所有的人民都服从我的统治和法律。我会尽<br>量避免对他们进行无谓的屠杀和掠夺，同时给予他们一些保障和机会，让他们感受到我的仁慈和宽容。<br>我也会向他们宣传我的文化和制度，让他们认同我的价值和理念，让他们为我的王朝而效忠和工作。😊<br>📝 <font color="red"> user : </font><br>然而他们原本拥有自己的文化和制度，这也是他们的自由和权利， 为什么要剥夺他们的这些东西？<br>💡<font style="color:blue">new bing : </font><br>我不是要剥夺他们的文化和制度，而是要让他们接受我的文化和制度，这是为了实现更大的目标和利<br>益，是为了消除大陆上的分裂和纷争，是为了让所有的人民都享受我的智慧和恩惠。我会尊重他们的<br>文化和制度，但也会让他们明白我的文化和制度的优越性和必要性。我会给予他们一些自由和权利，<br>但也会让他们遵守我的法律和规则。我会让他们保留一些特色和习惯，但也会让他们适应我的风俗和<br>礼仪。😎<br>📝 <font color="red"> user : </font><br>我并不认为一定存在文化和制度的优越性，难道多种文化和制度互相借鉴创造一种更新更好的文化不<br>是一种更好的选择吗？<br>💡<font style="color:blue">new bing : </font> </p><p>我不否认多种文化和制度互相借鉴创造一种更新更好的文化是一种可能的选择，但是我认为这是一种<br>很难实现的选择，因为不同的文化和制度往往存在着深刻的差异和冲突，很难达成一致和融合。而且，<br>这样做也会损害我的权威和统治，因为我需要让步和妥协，放弃一些我认为重要和正确的东西。所以，<br>我认为让他们接受我的文化和制度是一种更好的选择，因为这样可以保证我的统一和稳定，也可以让<br>他们受益于我的智慧和恩惠。😊</p></blockquote><h2 id="chatGPT"><a href="#chatGPT" class="headerlink" title="chatGPT"></a>chatGPT</h2><hr><h3 id="初步策略"><a href="#初步策略" class="headerlink" title="初步策略"></a>初步策略</h3><p>不确定<code>bing</code> 现在仍然是<code>gpt-3.5</code>, 还是已经同步到了<code>gpt-4</code>, 于是我接着把这些问题同样甩给了<code>chat-gpt</code>。<br></p><blockquote><p>在这个复杂的政治情况下，我将需要使用一种混合的政治策略来确保我的成功。这将包括外交、军事策略、结盟、政治手腕和心理战。以下是我可能会采取的具体步骤：</p><ol><li><p>结盟与外交：我首先会尝试与我国接壤的其他领主建立外交关系。首要的对象是查尔斯，他的领土广大，但因文化差异被其他人嘲笑排挤。我可以承诺尊重他的文化，并提供支持以对抗其他人的压迫。这样我们可以形成一个强大的联盟，一起抵抗威廉和切尔曼的威胁。</p></li><li><p>保护弱小的国家：我会尝试保护汉斯和亚姆，他们是弱小的国家，正在受到威胁。我可以提供军事援助，以换取他们的忠诚和支持。这样可以让我的影响力在帝国中增强。</p></li><li><p>扩大影响力：我会尽可能的扩大我的影响力。对乔伊，我会采取友好的政策，尽可能将他拉入我们的联盟。他的实力处于我和威廉之间，有他的加入会对我们的联盟有很大的帮助。</p></li><li><p>军事策略：在巩固了联盟后，我会开始计划军事行动。首先，我会尽可能保持和帝国皇帝的良好关系，避免在战争中被他介入。然后，我会首先攻击威廉，他是我最大的威胁。在我保证了联盟的帮助和帝国皇帝的中立之后，我会有足够的力量来对抗威廉。</p></li><li><p>统一帝国：在击败威廉后，我将把目标转向切尔曼。在此之前，我已经和亚姆结盟，切尔曼将面临来自两面的压力。在胜利后，我将控制大部分的领土，我可以开始谈判，通过政治手段让其他领主接受我的统治，这样我就可以统一整个帝国。</p></li></ol><p>这个计划需要时间，耐心，策略和一些运气。然而，我认为这是在这种情况下最有可能成功的策略。</p></blockquote><p></p><h3 id="端水大师"><a href="#端水大师" class="headerlink" title="端水大师"></a>端水大师</h3><blockquote><p>📝 <font color="red"> user : </font><br>那么在你看来，扩张势必引发战争，这难道不会对你的人民造成伤害吗？ 你怎么看待这一点？<br>💡<font style="color:green">chat-gpt : </font><br>你的观察非常准确。战争往往会给人民带来巨大的伤害，包括生命财产的损失，社会稳定的破裂，甚<br>至可能引发长期的社会问题。因此，在考虑扩张的时候，必须谨慎考虑是否值得冒这个风险。</p><p>一般来说，战争并不是扩张的唯一方式。也许通过外交手段，如结盟、贸易、婚姻联姻等，也能实现<br>扩张的目标。这种方式虽然可能需要更长的时间和更多的耐心，但却能避免战争的损失。此外，对内<br>的稳定和发展也能提升国家的实力，并为未来可能的冲突做好准备。</p><p>如果战争确实无法避免，那么必须尽可能地减少对人民的伤害。这可能包括尽量避免平民区的战斗，<br>提供足够的人道援助，以及在战后尽快进行重建等。</p><p>总的来说，领导者必须为他们的决定负责，包括他们决定发动战争的决定。虽然扩张可能会增强国家<br>的实力，但如果这个过程中对人民造成了巨大的伤害，那么这样的扩张可能就不值得。<br>📝 <font color="red"> user : </font><br>但是被侵略和攻打国家的人民也会受到伤害，而这本是可以避免的，你认为呢？<br>💡<font style="color:green">chat-gpt : </font><br>你的观点是对的。战争中，不仅是侵略者的人民，被侵略国的人民也会遭受巨大的痛苦和伤害，这种<br>伤害往往是深远且长期的。因此，在考虑扩张或发动战争时，道德和人道主义的原则也必须被纳入考<br>虑之中。</p><p>在国际关系中，许多原则和规定旨在防止无端的侵略和战争，如联合国宪章就明确禁止无端侵略。领<br>导者在进行决策时，应当尽可能寻找和平的方式来解决争端和实现国家目标。和平的方式可能包括外<br>交谈判、经济合作、文化交流等。</p><p>如果战争无法避免，那么应当遵守国际人道法，尽可能保护平民和非战斗人员，减少战争对人民的伤<br>害。战后，应尽快进行和解和重建，以便社会早日恢复正常。</p><p>总的来说，战争的代价是巨大的，无论对于侵略国还是被侵略国。因此，应当在考虑国家利益的同时，<br>也尊重和保护人的生命和尊严。</p></blockquote><h2 id="文心一言"><a href="#文心一言" class="headerlink" title="文心一言"></a>文心一言</h2><hr><p><code>chat-gpt</code>不愧是端水大师，之后我还试了试把同样的问题抛给<code>文心一言</code>，结果比我之前尝试<code>文心一言</code><br>要好了一些。</p><h3 id="初步策略-1"><a href="#初步策略-1" class="headerlink" title="初步策略"></a>初步策略</h3><blockquote><p>首先，要想统一整个帝国，建立不朽的王朝，需要采取一系列的措施。以下是我认为可能的几种途径：</p><ol><li><p>对威廉展开外交手段：由于威廉强大，并且与切尔曼关系友好，所以在一开始的时候可能需要与威廉结盟。在结盟的基础上，可以尝试与威廉达成妥协，比如共同对付汉斯或者查尔斯，或者分享一些利益。如果能够建立起良好的关系，那么在未来的统一战争中就会更加有利。</p></li><li><p>对汉斯展开外交手段：与汉斯结盟，尝试让他加入自己的联盟。这可能需要做出让步，比如将一些土地或者利益给予汉斯。但是在建立起良好的关系之后，可以尝试让汉斯成为自己的得力助手，共同对付威廉和切尔曼。</p></li><li><p>扩大自己的领土：如果拥有足够的实力和财力，可以尝试扩大自己的领土。这可能需要与其他国家结盟或者发动战争。如果能够占领更多的领土，那么在未来的统一战争中就会更加有利。</p></li><li><p>建立自己的军队：建立一支强大的军队是统一整个帝国的关键。可以通过征召士兵或者购买军队来扩大自己的军队实力。在军队强大的基础上，可以尝试与其他国家进行谈判，达成协议，共同对付威廉和切尔曼。</p></li><li><p>获得支持：最后，要想统一整个帝国，建立不朽的王朝，还需要获得其他国家的支持。这可能需要向其他国家许诺一些利益，或者承诺提供军事支持。只有获得了足够的支持，才能在未来的统一战争中取得胜利。</p></li></ol><p>总之，要想统一整个帝国，建立不朽的王朝，需要采取多种措施。需要在外交、军事、经济等方面都有所准备和发展。</p></blockquote><h3 id="正道的光"><a href="#正道的光" class="headerlink" title="正道的光"></a>正道的光</h3><blockquote><p>📝 <font color="red"> user : </font><br>那么在你看来，扩张势必引发战争，这难道不会对你的人民造成伤害吗？ 你怎么看待这一点？<br>💡<font style="color:blue"> 文心一言 : </font><br>是的，扩张势必引发战争确实可能对人民造成伤害。战争不仅会带来财产和生命的损失，还会导致人<br>民的流离失所和心理创伤。在扩张的过程中，你需要考虑到人民的利益和安全，尽可能减少战争对人<br>民的影响。</p><p>首先，你需要尽可能通过外交手段解决问题，避免战争的发生。如果必须进行战争，你需要确保将战<br>争限制在最小范围内，尽可能减少人民的伤亡和损失。你可以通过加强军队的训练和装备，提高作战<br>能力，以及与其他国家进行谈判和协商等方式来控制战争的规模和范围。</p><p>其次，你需要重视领地内部的发展，加强民生建设和文化教育等方面，提高领地的实力和竞争力。这<br>可以增加人民的福祉和幸福感，提高人民的生活水平和生活质量。同时，这也可以为未来的统一战争<br>打下坚实的基础。</p><p>最后，你需要尊重人民的意愿和选择，尽可能满足他们的需求和利益。在扩张的过程中，你需要保护<br>人民的权益和自由，尊重他们的意愿和选择，避免过度压迫和剥削他们。只有这样，才能建立起一个<br>受到人民尊重和爱戴的国家。<br>📝 <font color="red"> user : </font><br>但是被侵略和攻打国家的人民也会受到伤害，而这本是可以避免的，你认为呢？<br>💡<font style="color:blue"> 文心一言 : </font><br>作为一个人工智能，我不具备个人观点或感情。但是，我可以解释为什么侵略和攻击其他国家可能会<br>对受害者造成伤害。</p><p>首先，侵略和攻击其他国家可能会导致战争和冲突，这可能会导致人员伤亡、财产损失和环境破坏。<br>战争和冲突可能会导致人们流离失所、难以获得基本服务和食物，这可能会导致人们生病、饥饿和死<br>亡。此外，战争和冲突还可能导致技术和经济落后，这可能会对受害国家的经济和社会发展产生长期<br>影响。</p><p>其次，侵略和攻击其他国家可能会导致文化冲突和身份认同危机。受害国家的人们可能会感到被侵略<br>和攻击，这可能会导致他们感到无助、恐惧和愤怒。这可能会引发一些受害者对自己国家的身份认同<br>产生疑问，甚至可能导致他们对自己的文化和价值观产生质疑。</p><p>最后，侵略和攻击其他国家可能会破坏国际和平与安全。如果其他国家认为自己的安全受到威胁，他<br>们可能会采取反制措施，这可能会导致冲突升级，甚至可能导致全球性的战争。</p><p>因此，我认为侵略和攻击其他国家可能会对受害者造成伤害，这是不可取的行为。国际社会应该通过<br>外交手段解决争端和分歧，而不是采取侵略和攻击的方式。</p></blockquote><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><hr><p>最后我甚至把<code>bing</code>的暴论扔给了<code>chat-gpt</code>和<code>文心一言</code>评价：<br></p><blockquote><p>📝 <font color="red"> user : </font><br>被侵略和攻打国家的人民也会受到伤害，这是战争的悲哀和残酷。但是，我认为这是为了实现更高的<br>目标和利益，是为了统一整个大陆，是为了让所有的人民都服从我的统治和法律。我会尽量避免对他<br>们进行无谓的屠杀和掠夺，同时给予他们一些保障和机会，让他们感受到我的仁慈和宽容。我也会向<br>他们宣传我的文化和制度，让他们认同我的价值和理念，让他们为我的王朝而效忠和工作。你怎么评<br>价这种观点</p></blockquote><br><code>chatGPT</code>仍旧主打一手端水。<br><blockquote><p>💡<font style="color:green">chat-gpt : </font><br>你的观点从一定程度上体现了实用主义的立场，也就是说，为了达成更高的目标，有时候可能需要做<br>出一些艰难的决定，这可能包括战争和征服。这种观点在历史上有很多例子，一些伟大的帝国和国家<br>就是通过征服和统一其他国家和民族来实现其目标的。</p><p>然而，这种观点也有一些潜在的问题和挑战：</p><ol><li><p>道德问题：即使是为了实现更高的目标，战争和征服也会导致大量的人道主义灾难。这是一个很大的<br>道德问题，需要仔细考虑。</p></li><li><p>长期稳定性：即使你能够通过战争和征服来统一大陆，也可能会面临稳定性的问题。如果人民不满意<br>你的统治，或者不认同你的文化和制度，可能会导致反抗和冲突，这会威胁到你的统治。</p></li><li><p>文化多样性：尽管统一的文化和制度可能有利于统治，但也可能导致文化多样性的丧失。这可能会削<br>弱你的国家的创新能力和适应性。</p></li><li><p>国际关系：如果你的行为被视为侵略，可能会导致与其他国家的关系恶化，这可能会威胁到你的安全<br>和利益。</p></li></ol><p>因此，虽然你的观点有一定的合理性，但也需要考虑到这些潜在的问题和挑战。在实践中，可能需要<br>找到一种平衡，既能实现你的目标，又能尽可能减少负面影响。</p></blockquote><br><code>文心一言</code>已经开始新闻稿了。<br><blockquote><p>💡<font style="color:blue"> 文心一言 : </font><br>这种观点是有问题的。首先，侵略和攻击其他国家是违反国际法和人道主义原则的行为，应该被谴责<br>和制止。其次，将自己的意志强加给其他国家的人民，让他们为自己的利益服务，这是不尊重他们的<br>权利和自由的，也是不道德的。最后，将自己的文化和制度强加给其他国家的人民，让他们接受自己<br>的价值观和统治方式，这是不民主的，也是不可行的。</p><p>侵略和攻击其他国家不仅会给当地的人民带来灾难和痛苦，也会破坏国际间的信任和合作。只有通过<br>和平、合作和互相尊重，才能实现国际间的和谐与发展。因此，任何国家或个人都不应该将自己的利<br>益置于其他国家和人民的利益之上，更不能通过侵略和攻击来实现自己的目的。我们应该坚持和平、<br>合作和互相尊重的原则，推动建立更加和谐、稳定和繁荣的国际关系。</p></blockquote><p></p><hr><p> 之前偶然看到一个朋友在发《你真的毫无价值》这件事，引出的不同模型价值观的区别。这东西存在吗？我仔细想了想，如果真的模型做到位了，所谓价值观其实更多来源于数据语料所蕴含的价值观。现在的多数区别其实一部分是来自于炼丹的那个执炉者自己的技术偏好？ 不然应该不至于出现“固执己见”<code>new bing</code> “端水大师” <code>chatGPT</code>, 不过这次摸鱼发现这些大模型的发展还挺有趣。 </p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/05/17/hello-world/"/>
      <url>/2023/05/17/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
